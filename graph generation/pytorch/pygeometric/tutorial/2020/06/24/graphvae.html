<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Molecular graph generation with PyTorch and PyGeometric | Hitchhiker’s guide to bayesian learning</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Molecular graph generation with PyTorch and PyGeometric" />
<meta name="author" content="Anirudh Jain" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="We use GraphVAE for molecular generation with one shot generation of a probabilistic graph with predefined maximum size." />
<meta property="og:description" content="We use GraphVAE for molecular generation with one shot generation of a probabilistic graph with predefined maximum size." />
<link rel="canonical" href="https://sponde25.github.io/approxbayes/graph%20generation/pytorch/pygeometric/tutorial/2020/06/24/graphvae.html" />
<meta property="og:url" content="https://sponde25.github.io/approxbayes/graph%20generation/pytorch/pygeometric/tutorial/2020/06/24/graphvae.html" />
<meta property="og:site_name" content="Hitchhiker’s guide to bayesian learning" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-24T00:00:00-05:00" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"Anirudh Jain"},"description":"We use GraphVAE for molecular generation with one shot generation of a probabilistic graph with predefined maximum size.","@type":"BlogPosting","headline":"Molecular graph generation with PyTorch and PyGeometric","dateModified":"2020-06-24T00:00:00-05:00","datePublished":"2020-06-24T00:00:00-05:00","url":"https://sponde25.github.io/approxbayes/graph%20generation/pytorch/pygeometric/tutorial/2020/06/24/graphvae.html","mainEntityOfPage":{"@type":"WebPage","@id":"https://sponde25.github.io/approxbayes/graph%20generation/pytorch/pygeometric/tutorial/2020/06/24/graphvae.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/approxbayes/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://sponde25.github.io/approxbayes/feed.xml" title="Hitchhiker's guide to bayesian learning" /><!-- the google_analytics_id gets auto inserted from the config file -->



<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-159883250-1','auto');ga('require','displayfeatures');ga('send','pageview');</script>

<link rel="shortcut icon" type="image/x-icon" href="/approxbayes/images/favicon.ico"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Molecular graph generation with PyTorch and PyGeometric | Hitchhiker’s guide to bayesian learning</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Molecular graph generation with PyTorch and PyGeometric" />
<meta name="author" content="Anirudh Jain" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="We use GraphVAE for molecular generation with one shot generation of a probabilistic graph with predefined maximum size." />
<meta property="og:description" content="We use GraphVAE for molecular generation with one shot generation of a probabilistic graph with predefined maximum size." />
<link rel="canonical" href="https://sponde25.github.io/approxbayes/graph%20generation/pytorch/pygeometric/tutorial/2020/06/24/graphvae.html" />
<meta property="og:url" content="https://sponde25.github.io/approxbayes/graph%20generation/pytorch/pygeometric/tutorial/2020/06/24/graphvae.html" />
<meta property="og:site_name" content="Hitchhiker’s guide to bayesian learning" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-24T00:00:00-05:00" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"Anirudh Jain"},"description":"We use GraphVAE for molecular generation with one shot generation of a probabilistic graph with predefined maximum size.","@type":"BlogPosting","headline":"Molecular graph generation with PyTorch and PyGeometric","dateModified":"2020-06-24T00:00:00-05:00","datePublished":"2020-06-24T00:00:00-05:00","url":"https://sponde25.github.io/approxbayes/graph%20generation/pytorch/pygeometric/tutorial/2020/06/24/graphvae.html","mainEntityOfPage":{"@type":"WebPage","@id":"https://sponde25.github.io/approxbayes/graph%20generation/pytorch/pygeometric/tutorial/2020/06/24/graphvae.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<link href="https://unpkg.com/@primer/css/dist/primer.css" rel="stylesheet" />
<link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.7/css/all.css"><link type="application/atom+xml" rel="alternate" href="https://sponde25.github.io/approxbayes/feed.xml" title="Hitchhiker's guide to bayesian learning" /><!-- the google_analytics_id gets auto inserted from the config file -->



<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-159883250-1','auto');ga('require','displayfeatures');ga('send','pageview');</script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head><body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/approxbayes/">Hitchhiker&#39;s guide to bayesian learning</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/approxbayes/about/">About Me</a><a class="page-link" href="/approxbayes/search/">Search</a><a class="page-link" href="/approxbayes/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Molecular graph generation with PyTorch and PyGeometric</h1><p class="page-description">We use <a href='https://arxiv.org/abs/1802.03480'>GraphVAE</a> for molecular generation with one shot generation of a probabilistic graph with predefined maximum size.</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2020-06-24T00:00:00-05:00" itemprop="datePublished">
        Jun 24, 2020
      </time>• 
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name">Anirudh Jain</span></span>
       • <span class="read-time" title="Estimated read time">
    
    
      8 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/approxbayes/categories/#graph generation">graph generation</a>
        &nbsp;
      
        <a class="category-tags-link" href="/approxbayes/categories/#pytorch">pytorch</a>
        &nbsp;
      
        <a class="category-tags-link" href="/approxbayes/categories/#pygeometric">pygeometric</a>
        &nbsp;
      
        <a class="category-tags-link" href="/approxbayes/categories/#tutorial">tutorial</a>
        
      
      </p>
    

    
      
        <div class="pb-5 d-flex flex-wrap flex-justify-end">
          <div class="px-2">

    <a href="https://github.com/sponde25/approxbayes/tree/master/_notebooks/2020-06-24-graphvae.ipynb" role="button" target="_blank">
<img class="notebook-badge-image" src="/approxbayes/assets/badges/github.svg" alt="View On GitHub">
    </a>
</div>

          <div class="px-2">
    <a href="https://mybinder.org/v2/gh/sponde25/approxbayes/master?filepath=_notebooks%2F2020-06-24-graphvae.ipynb" target="_blank">
        <img class="notebook-badge-image" src="/approxbayes/assets/badges/binder.svg" alt="Open In Binder"/>
    </a>
</div>

          <div class="px-2">
    <a href="https://colab.research.google.com/github/sponde25/approxbayes/blob/master/_notebooks/2020-06-24-graphvae.ipynb" target="_blank">
        <img class="notebook-badge-image" src="/approxbayes/assets/badges/colab.svg" alt="Open In Colab"/>
    </a>
</div>
        </div>
      </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h1"><a href="#Requirements">Requirements </a></li>
<li class="toc-entry toc-h1"><a href="#Introduction">Introduction </a></li>
<li class="toc-entry toc-h1"><a href="#Model">Model </a></li>
<li class="toc-entry toc-h1"><a href="#Results">Results </a></li>
<li class="toc-entry toc-h1"><a href="#Conclusion">Conclusion </a></li>
</ul><!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2020-06-24-graphvae.ipynb
-->

<div class="container" id="notebook-container">
        
    
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Requirements">
<a class="anchor" href="#Requirements" aria-hidden="true"><span class="octicon octicon-link"></span></a>Requirements<a class="anchor-link" href="#Requirements"> </a>
</h1>
<p>The following packages need to be installed:</p>
<ul>
<li>rdkit</li>
<li>pytorch</li>
<li>torch_geometric</li>
<li>networkx</li>
</ul>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>

<span class="c1">#Initial imports</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>
<span class="kn">import</span> <span class="nn">tqdm</span>
<span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span> 
<span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="kn">import</span> <span class="n">AllChem</span>
<span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="kn">import</span> <span class="n">Draw</span>
<span class="kn">from</span> <span class="nn">rdkit.Chem.Draw</span> <span class="kn">import</span> <span class="n">IPythonConsole</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">DataLoader</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch_geometric.data</span> <span class="kn">import</span> <span class="n">Batch</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">random_split</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Introduction">
<a class="anchor" href="#Introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction<a class="anchor-link" href="#Introduction"> </a>
</h1>
<p>We represent a molecule as graph $G = (\mathcal{X, A})$ using PyGeometric framework. Each molecule is represented by a feature matrix $\mathcal{X}$ and adjacency matrix $\mathcal{A}$. We use QM9 dataset from <a href="https://arxiv.org/abs/1703.00564">MoleculeNet:A Benchmark for Molecular Machine Learning</a> implemented in <code>torch_geometric.datasets.QM9</code>. PyGeometric relies on rdkit to process the SMILES string and convert them into graphs.</p>
<p>We modify the data processing script in two ways:</p>
<ul>
<li>We strip hydrogen atoms from the molecules to keep only the heavy atoms</li>
<li>We kekulize the molecules to convert aromatic rings to Kekule form
The modified script can be found <a href="https://gist.github.com/sponde25/7dfa5492c21c007cf1e60a02dced1334">here</a>
</li>
</ul>
<p>After processing the dataset, we have a set of molecules with 4 heavy atoms (C, N, O, F) and 3 bond types (SINGLE, DOUBLE and TRIPLE) with maximum graph size of 9.</p>
<p>The decoder outputs the graph as one-hot encoded vectors for atoms <code>[9 x 5]</code> and bonds <code>[9 x 4]</code>. The label 0 represents empty atom or edge.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#Imports for data pre-processing</span>

<span class="kn">import</span> <span class="nn">torch_geometric</span>
<span class="kn">from</span> <span class="nn">qm9_modified</span> <span class="kn">import</span> <span class="n">QM9</span>
<span class="kn">from</span> <span class="nn">torch_geometric.utils.convert</span> <span class="kn">import</span> <span class="n">to_networkx</span>
<span class="kn">import</span> <span class="nn">networkx</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Setting up variables for the dataset</span>

<span class="n">MAX_ATOM</span> <span class="o">=</span> <span class="mi">5</span> 
<span class="n">MAX_EDGE</span> <span class="o">=</span> <span class="mi">4</span> 
<span class="n">path</span> <span class="o">=</span> <span class="s1">'/scratch/project_2002655/datasets/qm9_noH'</span> <span class="c1"># Change the path for your local directory structure</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">QM9</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

<span class="c1"># Store the max. graph size</span>
<span class="n">MAX_N</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">MAX_N</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">MAX_N</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">MAX_E</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">MAX_N</span> <span class="o">*</span> <span class="p">(</span><span class="n">MAX_N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'MAX ATOMS: </span><span class="si">{}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">MAX_N</span><span class="p">))</span>    <span class="c1"># Maximum number of atoms in a graph in the dataset</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'MAX EDGE: </span><span class="si">{}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">MAX_E</span><span class="p">))</span>     <span class="c1"># Corresponding size of upper triangle adjacency matrix </span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>MAX ATOMS: 9
MAX EDGE: 72
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><code>torch_geometric</code> stores the graph as <code>torch_geometric.data.Data</code> and we generate the one-hot representation of the graph $G$ as described above. For each graph $G$, we create a vector $\mathcal{X}$ as one-hot encoded for atom of dimension <code>[MAX_N x MAX_ATOM]</code> and vector bond of dimension <code>[MAX_E x MAX_EDGE]</code>.</p>
<p><img src="/approxbayes/images/copied_from_nb/../images/data_representation.png" alt="" title="A visualization of the graph, atom and edge representations"></p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># We create a matrix to map the index of the edge vector $\mathcal{A}$ to the upper triangular adjacency matrix.</span>

<span class="n">index_array</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">MAX_N</span><span class="p">,</span> <span class="n">MAX_N</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MAX_N</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MAX_N</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">index_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="n">idx</span><span class="o">+=</span><span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="n">index_array</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>tensor([[ 0,  0,  1,  2,  3,  4,  5,  6,  7],
        [ 0,  0,  8,  9, 10, 11, 12, 13, 14],
        [ 0,  0,  0, 15, 16, 17, 18, 19, 20],
        [ 0,  0,  0,  0, 21, 22, 23, 24, 25],
        [ 0,  0,  0,  0,  0, 26, 27, 28, 29],
        [ 0,  0,  0,  0,  0,  0, 30, 31, 32],
        [ 0,  0,  0,  0,  0,  0,  0, 33, 34],
        [ 0,  0,  0,  0,  0,  0,  0,  0, 35],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0]])
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We process the <code>torch_geometric.dataset</code> to generate matrices $\mathcal{X}$ and $\mathcal{A}$ which act as the ground truth for our decoder. We will also setup utility functions to convert between the vector representation $(\mathcal{X}, \mathcal{A})$ and <code>torch_geometric.data</code> representation $\mathcal{G}$. We use the following key for atoms and bonds:</p>

<pre><code>    C: 1    SINGLE: 1
    N: 2    DOUBLE: 2
    O: 3    TRIPLE: 3
    F: 4</code></pre>
<p><code>0</code> is the placeholder label for empty entry.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Initialize the labels with -1</span>
<span class="n">edge_labels</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">),</span> <span class="n">MAX_E</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">atom_labels</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">),</span> <span class="n">MAX_N</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
    <span class="n">edge_attr</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">edge_attr</span>      <span class="c1"># One hot encoded bond labels</span>
    <span class="n">edge_index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">edge_index</span>    <span class="c1"># Bond indices as one hot adjacency list</span>
    <span class="n">upper_index</span> <span class="o">=</span> <span class="n">edge_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">edge_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Bond indices as upper triangular adjacency matrix</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">edge_label</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">edge_attr</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="c1"># Bond labels from one hot vectors</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>              <span class="c1"># One hot encoded atom labels</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">atom_label</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>        <span class="c1"># Atom labels from one hot vectors</span>
    <span class="c1"># Expand the label vectors to size [MAX_N x MAX_ATOM] and [MAX_E x MAX_EDGE]</span>
    <span class="n">atom_labels</span><span class="p">[</span><span class="n">idx</span><span class="p">][:</span><span class="nb">len</span><span class="p">(</span><span class="n">atom_label</span><span class="p">)]</span> <span class="o">=</span> <span class="n">atom_label</span>
    <span class="n">a0</span> <span class="o">=</span> <span class="n">edge_index</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">upper_index</span><span class="p">]</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">edge_index</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">upper_index</span><span class="p">]</span>
    <span class="n">up_idx</span> <span class="o">=</span> <span class="n">index_array</span><span class="p">[</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">]</span>
    <span class="n">edge_labels</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">up_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_label</span><span class="p">[</span><span class="n">upper_index</span><span class="p">]</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">atom_labels</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">edge_labels</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now that we have the dataset represented as $(\mathcal{X}, \mathcal{A})$ let's plot some graphs to visually check if the molecules are as we expected. We use <code>rdkit</code> to plot the molecules which does a lot of having lifting for us. The function <code>graphToMol</code> takes in the vectors $(\mathcal{X}, \mathcal{A})$ and returns an object of type <code>rdkit.Mol</code>. We can also obtain visualizations for the graphs $\mathcal{G}$ by using <code>torch_geometric.utils.convert.to_networkx</code> and then ploting the netowrkx graph. But <code>rdkit</code> plots the molecules in a canonical orientation and is built to minimize intramolecular clashes, i.e. to maximize the clarity of the drawing.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>

<span class="k">def</span> <span class="nf">get_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index_array</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">if</span><span class="p">(</span><span class="n">index_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">index</span><span class="p">):</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">graphToMol</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>

    <span class="n">possible_atoms</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="s1">'H'</span><span class="p">,</span>
        <span class="mi">1</span><span class="p">:</span> <span class="s1">'C'</span><span class="p">,</span>
        <span class="mi">2</span><span class="p">:</span> <span class="s1">'N'</span><span class="p">,</span>
        <span class="mi">3</span><span class="p">:</span> <span class="s1">'O'</span><span class="p">,</span>
        <span class="mi">4</span><span class="p">:</span> <span class="s1">'F'</span>
    <span class="p">}</span>
    <span class="n">possible_edges</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">1</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">,</span> 
        <span class="mi">2</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">,</span> 
        <span class="mi">3</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">TRIPLE</span>
    <span class="p">}</span>
    <span class="n">max_n</span> <span class="o">=</span> <span class="mi">9</span>
    
    <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RWMol</span><span class="p">()</span>
    <span class="n">rem_idxs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atom</span><span class="p">:</span>    
        <span class="n">atom_symbol</span> <span class="o">=</span> <span class="n">possible_atoms</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">AddAtom</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="n">atom_symbol</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">rem_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">index_array</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a0</span> <span class="ow">in</span> <span class="n">rem_idxs</span> <span class="ow">or</span> <span class="n">a1</span> <span class="ow">in</span> <span class="n">rem_idxs</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">bond_type</span> <span class="o">=</span> <span class="n">possible_edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
            <span class="n">mol</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">bond_type</span><span class="p">)</span>
    <span class="n">rem_idxs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rem_idxs</span><span class="p">:</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">RemoveAtom</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mol</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># We pick 9 random molecules from QM9 dataset to plot</span>
<span class="n">mols</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">9</span><span class="p">):</span>
    <span class="n">mols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">graphToMol</span><span class="p">(</span><span class="n">atom_labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">edge_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
<span class="n">Chem</span><span class="o">.</span><span class="n">Draw</span><span class="o">.</span><span class="n">IPythonConsole</span><span class="o">.</span><span class="n">ShowMols</span><span class="p">(</span><span class="n">mols</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="data:image/png;base64,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%0A">
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The final step is to create a custom dataset for PyTorch which combines the two representations $\mathcal{G}$ and $(\mathcal{X}, \mathcal{A})$. The dataset returns a list containing the graph, atom label and edge label. We also define a <code>collate_fn</code> which creates mini batches for the data loader that we will need for training and testing our model.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>

<span class="c1"># Utility function to combine the torch_geometric.data and torch.tensor into one mini batch</span>
<span class="k">def</span> <span class="nf">collate_fn</span><span class="p">(</span><span class="n">datas</span><span class="p">):</span>
    <span class="n">graphs</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">datas</span><span class="p">:</span>
        <span class="n">graph</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">graphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="n">graphs</span> <span class="o">=</span> <span class="n">Batch</span><span class="o">.</span><span class="n">from_data_list</span><span class="p">(</span><span class="n">graphs</span><span class="p">)</span>
    <span class="n">atoms</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graphs</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">edges</span>

<span class="c1"># Returns the dataloader with a given batch size</span>
<span class="k">def</span> <span class="nf">get_dataloader</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">collate_fn</span><span class="o">=</span><span class="n">collate_fn</span><span class="p">)</span>

<span class="c1"># Create the dataset from the QM9 dataset from PyGeometric and the label matrices</span>
<span class="k">class</span> <span class="nc">GraphTensorDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">graph_dataset</span> <span class="o">=</span> <span class="n">QM9</span><span class="p">(</span><span class="s1">'/scratch/project_2002655/datasets/qm9_noH'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atom_labels</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">'/scratch/project_2002655/drug_discovery/saved/atom_labels_noH.tensor'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_labels</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">'/scratch/project_2002655/drug_discovery/saved/edge_labels_noH.tensor'</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_dataset</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">graphs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_dataset</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_labels</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_labels</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">graphs</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">edges</span>
    
    <span class="c1"># return the subset of data with the specified size</span>
    <span class="k">def</span> <span class="nf">get_splits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span> <span class="n">cv_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">total_data</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_dataset</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cv_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trainset</span><span class="p">,</span> <span class="n">testset</span> <span class="o">=</span> <span class="n">random_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">train_size</span><span class="o">+</span><span class="n">cv_size</span><span class="p">,</span> <span class="n">total_data</span> <span class="o">-</span> <span class="n">train_size</span> <span class="o">-</span> <span class="n">cv_size</span><span class="p">])</span>
            <span class="n">trainset</span><span class="p">,</span> <span class="n">cvset</span> <span class="o">=</span> <span class="n">random_split</span><span class="p">(</span><span class="n">trainset</span><span class="p">,</span> <span class="p">[</span><span class="n">train_size</span><span class="p">,</span> <span class="n">cv_size</span><span class="p">])</span>
            <span class="n">testset</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">random_split</span><span class="p">(</span><span class="n">testset</span><span class="p">,</span> <span class="p">[</span><span class="n">test_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">testset</span><span class="p">)</span> <span class="o">-</span> <span class="n">test_size</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trainset</span> <span class="o">=</span> <span class="n">trainset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cvset</span> <span class="o">=</span> <span class="n">cvset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">testset</span> <span class="o">=</span> <span class="n">testset</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trainset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">testset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cvset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trainset</span><span class="p">,</span> <span class="n">testset</span> <span class="o">=</span> <span class="n">random_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">train_size</span><span class="p">,</span> <span class="n">total_data</span> <span class="o">-</span> <span class="n">train_size</span><span class="p">])</span>
            <span class="n">testset</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">random_split</span><span class="p">(</span><span class="n">testset</span><span class="p">,</span> <span class="p">[</span><span class="n">test_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">testset</span><span class="p">)</span> <span class="o">-</span> <span class="n">test_size</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trainset</span> <span class="o">=</span> <span class="n">trainset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">testset</span> <span class="o">=</span> <span class="n">testset</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trainset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">testset</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we wrap up this section by creating the train and test loaders with a mini batch of size <code>32</code>. We train the model on a subset of 500 molecules and test the reconstruction on 10000 molecules. To monitor training we look at three metrics averaged over the minibatch:</p>
<ul>
<li>cross-entropy loss over the atom and edge labels</li>
<li>Atom label accuracy</li>
<li>Edge label accuracy </li>
</ul>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dataset</span> <span class="o">=</span> <span class="n">GraphTensorDataset</span><span class="p">()</span>
<span class="n">train_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="n">test_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># We set the random seed before the random split so we can get the same subset for reproducibility </span>
<span class="n">trainset</span><span class="p">,</span> <span class="n">testset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">get_splits</span><span class="p">(</span><span class="n">train_size</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span>
<span class="n">trainloader</span> <span class="o">=</span> <span class="n">get_dataloader</span><span class="p">(</span><span class="n">trainset</span><span class="p">)</span>
<span class="n">testloader</span> <span class="o">=</span> <span class="n">get_dataloader</span><span class="p">(</span><span class="n">testset</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Model">
<a class="anchor" href="#Model" aria-hidden="true"><span class="octicon octicon-link"></span></a>Model<a class="anchor-link" href="#Model"> </a>
</h1>
<p>Our generative model is a VAE with an encoder $q_\phi (\textbf{z} | \mathcal{G})$ and a decoder $p_\theta (\mathcal{X}, \mathcal{A} | \textbf{z})$ parameterized by $\phi$ and $\theta$ respectively. We place a prior over the latent vector $\textbf{z} \sim \mathcal{N}(0, I)$ which act as a regularizer to our model. Our goal is to map the graph $\mathcal{G}$ into the latent vector $\textbf{z}$ and generate new graphs by using the decoder to map new latent vectors sampled from the prior.</p>
<p><strong><em>Encoder</em></strong>: For a graph $\mathcal{G}(\mathcal{V}, \mathcal{E})$ with upto N nodes, we aim to map the graph to a latent vector $\textbf{z} \in \mathbb{R}^D$. We use graph convolution network(GCN) to learn graph level feature vector $h_{\mathcal{G}}$. For each node $\mathcal{v} \in \mathcal{V}$, GCN update the node level features as,
\begin{equation}
    h_{\mathcal{v}} = \sum_{\mathcal{u} \in Nbd(\mathcal{v}, \mathcal{G})}\Phi (W_l^T X_{\mathcal{u}})
\end{equation}
where $Nbd(\mathcal{v}, \mathcal{G})$ is the neighborhood of node $\mathcal{v}$ in graph $\mathcal{G}$, $W_l$ are the shared weights analogous to the kernel in convolution layer and $X_\mathcal{u}$ is the feature vector of node $\mathcal{u}$. 
After 2 graph convolution layers, we create a graph level vector representation by taking the mean of all node feature vectors $h_{\mathcal{v}}$.
\begin{equation}
    h_{\mathcal{G}} = 1 / |\mathcal{V}| \sum_{\mathcal{v} \in \mathcal{V}} h_{\mathcal{v}}
\end{equation}
Now we use fully connected layers to learn the latent vector $\textbf{z}$ with the inference model as,
\begin{equation}
    q(\textbf{z}|\mathcal{G}) = \mathcal{N}(\textbf{z}|\mu(h_{\mathcal{G}}), \sigma^2(h_{\mathcal{G}}))
\end{equation}</p>
<p><img src="/approxbayes/images/copied_from_nb/../images/encoder_arch.png" alt="" title="Visualization of the encoder architecture"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Results">
<a class="anchor" href="#Results" aria-hidden="true"><span class="octicon octicon-link"></span></a>Results<a class="anchor-link" href="#Results"> </a>
</h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Conclusion">
<a class="anchor" href="#Conclusion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusion<a class="anchor-link" href="#Conclusion"> </a>
</h1>
</div>
</div>
</div>
</div>



  </div><a class="u-url" href="/approxbayes/graph%20generation/pytorch/pygeometric/tutorial/2020/06/24/graphvae.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/approxbayes/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/approxbayes/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/approxbayes/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>I am a doctoral candidate at the Probabilistic Machine Learning group at Aalto University. These blogs are a collection of paper summaries and (hopefully interactive) tutorials of stuff I struggled with or find interesting.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/sponde25" title="sponde25"><svg class="svg-icon grey"><use xlink:href="/approxbayes/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/sponde25" title="sponde25"><svg class="svg-icon grey"><use xlink:href="/approxbayes/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
